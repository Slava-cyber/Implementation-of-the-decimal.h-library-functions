        -:    0:Source:s21_test.c
        -:    0:Graph:s21_test_gcov.gcno
        -:    0:Data:s21_test_gcov.gcda
        -:    0:Runs:34
        -:    1:#include <check.h>
        -:    2:#include <float.h>
        -:    3:#include <stdio.h>
        -:    4:#include <stdlib.h>
        -:    5:#include <string.h>
        -:    6:#include<stdbool.h>
        -:    7:#include "s21_decimal.h"
        -:    8:// MARK: - Convert functions
        -:    9:/*-----------Convert from int to decimal-----------*/
        1:   10:START_TEST(s21_decimal_test_from_int) {
        -:   11:    s21_decimal dec_y;
        1:   12:    char binary[8][129] = {
        -:   13:        "000000000000000000000000000000000000000000000000000000000000000000000000"
        -:   14:        "00000000000000000000000000000000000000000000100011001010",
        -:   15:        "000000000000000000000000000000000000000000000000000000000000000000000000"
        -:   16:        "00000000000000000000000000000000000000011110000011110011",
        -:   17:        "000000000000000000000000000000000000000000000000000000000000000000000000"
        -:   18:        "00000000000000000000000000000000000000000000000000000001",
        -:   19:        "000000000000000000000000000000000000000000000000000000000000000000000000"
        -:   20:        "00000000000000000000000000000000011000001101011001101010",
        -:   21:        "100000000000000000000000000000000000000000000000000000000000000000000000"
        -:   22:        "00000000000000000000000000000000101110111101111100001011",
        -:   23:        "000000000000000000000000000000000000000000000000000000000000000000000000"
        -:   24:        "00000000000000000000000000000000000000000000000000000000",
        -:   25:        "000000000000000000000000000000000000000000000000000000000000000000000000"
        -:   26:        "00000000000000000000000000000000100110001001011001111111",
        -:   27:        "000000000000000000000000000000000000000000000000000000000000000000000000"
        -:   28:        "00000000000000000000000000000101111101011110000100000000"};
        1:   29:    unsigned examples[8] = {2250, 123123, 1, 6346346, -12312331, 0, 9999999, 1E+08};
        -:   30:    char arr[129];
        9:   31:    for (int j = 0; j < 8; j++) {
        8:   32:        s21_from_int_to_decimal(examples[j], &dec_y);
     1032:   33:        for (int i = 0; i < 128; i++) {
     1024:   34:            arr[i] = check_bit(127 - i, dec_y) + 48;
        -:   35:        }
        8:   36:        arr[128] = '\0';
       8*:   37:        ck_assert_str_eq(binary[j], arr);
        -:   38:    }
        1:   39:}
        -:   40:END_TEST
        -:   41:/*-----------Convert from float to decimal-----------*/
        1:   42:START_TEST(s21_decimal_test_from_float) {
        -:   43:    s21_decimal dec_y;
        1:   44:    char binary[4][129] = {
        -:   45:        "000000000000010000000000000000000000000000000000000000000000000000000000"
        -:   46:        "00000000000000000000000000000000000000000011000000101100",
        -:   47:        "100000000000010100000000000000000000000000000000000000000000000000000000"
        -:   48:        "00000000000000000000000000000000000000011000011011000000",
        -:   49:        "000000000000010100000000000000000000000000000000000000000000000000000000"
        -:   50:        "00000000000000000000000000000000000000000000000000010111",
        -:   51:        "000000000000001100000000000000000000000000000000000000000000000000000000"
        -:   52:        "00000000000000000000000000000000000000011000100001000101"};
        1:   53:    float examples[4] = {1.2332, -1.00032, 0.00023, 100.421};
        -:   54:    char arr[129];
        5:   55:    for (int j = 0; j < 4; j++) {
        4:   56:        s21_from_float_to_decimal(examples[j], &dec_y);
      516:   57:        for (int i = 0; i < 128; i++) {
      512:   58:            arr[i] = check_bit(127 - i, dec_y) + 48;
        -:   59:        }
        4:   60:        arr[128] = '\0';
       4*:   61:        ck_assert_str_eq(binary[j], arr);
        -:   62:    }
        1:   63:}
        -:   64:END_TEST
        -:   65:/*-----------Convert from decimal to int-----------*/
        1:   66:START_TEST(s21_decimal_test_from_decimal_to_int) {
        1:   67:    int valuesA[] = {
        -:   68:        9403, 111, 0, 100, -1123,
        -:   69:    };
        1:   70:    int valuesB[] = {202, 34, 0, 100, -111};
        1:   71:    int originValues[] = {9605, 145, 0, 200, -1234};
        -:   72:    s21_decimal src1, src2;
        -:   73:    int a;
        -:   74:    int b;
        -:   75:    int res_origin;
        -:   76:    int res_our_dec;
        6:   77:    for (int i = 0; i < 5; i++) {
        5:   78:        res_our_dec = 0;
        5:   79:        a = valuesA[i];
        5:   80:        b = valuesB[i];
        5:   81:        res_origin = originValues[i];
        5:   82:        s21_from_int_to_decimal(a, &src1);
        5:   83:        s21_from_int_to_decimal(b, &src2);
        5:   84:        s21_decimal res_od = s21_add(src1, src2);
        5:   85:        s21_from_decimal_to_int(res_od, &res_our_dec);
       5*:   86:        ck_assert_int_eq(res_our_dec, res_origin);
        -:   87:    }
        1:   88:}
        -:   89:END_TEST
        -:   90:/*-----------Convert from decimal to float-----------*/
        1:   91:START_TEST(s21_decimal_test_from_decimal_to_float) {
        1:   92:    float valuesA[] = {
        -:   93:        0.111, 0.002, 0, -0.333, 0.000001,
        -:   94:    };
        1:   95:    float valuesB[] = {0.111, 0.003, 0, -0.111, 0.000005};
        1:   96:    float originValues[] = {0.222, 0.005, 0, -0.444, 0.000006};
        -:   97:    s21_decimal src1, src2;
        -:   98:    float a;
        -:   99:    float b;
        -:  100:    float res_origin;
        -:  101:    float res_our_dec;
        6:  102:    for (int i = 0; i < 5; i++) {
        5:  103:        res_our_dec = 0;
        5:  104:        a = valuesA[i];
        5:  105:        b = valuesB[i];
        5:  106:        res_origin = originValues[i];
        5:  107:        s21_from_float_to_decimal(a, &src1);
        5:  108:        s21_from_float_to_decimal(b, &src2);
        5:  109:        s21_decimal res_od = s21_add(src1, src2);
        5:  110:        s21_from_decimal_to_float(res_od, &res_our_dec);
       5*:  111:        ck_assert_float_eq(res_our_dec, res_origin);
        -:  112:    }
        1:  113:}
        -:  114:END_TEST
        -:  115:
        -:  116:// MARK: - Arithmetics operations
        -:  117:
        -:  118:/*-----------add-----------*/
        1:  119:START_TEST(s21_decimal_test_add) {
        1:  120:    int valuesA[] = {100, -100000, 0, -111111, 1E+02};
        1:  121:    int valuesB[] = {100, -100000, 0, 111111, 1E+03};
        1:  122:    int originValues[] = { 200, -200000, 0, 0, 1100 };
        -:  123:    s21_decimal src1, src2;
        -:  124:    int a;
        -:  125:    int b;
        -:  126:    int res_origin;
        -:  127:    int res_our_dec;
        6:  128:    for (int i = 0; i < 5; i++) {
        5:  129:        res_our_dec = 0;
        5:  130:        a = valuesA[i];
        5:  131:        b = valuesB[i];
        5:  132:        res_origin = originValues[i];
        5:  133:        s21_from_int_to_decimal(a, &src1);
        5:  134:        s21_from_int_to_decimal(b, &src2);
        5:  135:        s21_decimal res_od = s21_add(src1, src2);
        5:  136:        s21_from_decimal_to_int(res_od, &res_our_dec);
       5*:  137:        ck_assert_int_eq(res_our_dec, res_origin);
        -:  138:}
        1:  139:} END_TEST
        -:  140:
        1:  141:START_TEST(s21_decimal_test_add1) {
        -:  142:    s21_decimal src1, src2;
        1:  143:    int a = -46;
        1:  144:    float b = 0.0 / 0.0;
        1:  145:    float res_our_dec = 0.0;
        -:  146:    float res_origin;
        1:  147:    s21_from_int_to_decimal(a, &src1);
        1:  148:    s21_from_float_to_decimal(b, &src2);
        1:  149:    s21_decimal res_od = s21_add(src1, src2);
        1:  150:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  151:    ck_assert_float_eq(res_od.value_type, s21_NAN);
       1*:  152:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  153:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  154:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  155:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  156:    a = -1234;
        1:  157:    b = -221.234;
        1:  158:    res_our_dec = 0.0;
        1:  159:    s21_from_float_to_decimal(a, &src1);
        1:  160:    s21_from_float_to_decimal(b, &src2);
        1:  161:    res_origin = -1455.234;
        1:  162:    res_od = s21_add(src1, src2);
        1:  163:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  164:    ck_assert_float_eq(res_our_dec, res_origin);
        1:  165:    a = -1.0;
        1:  166:    b = 1.0;
        1:  167:    res_our_dec = 0.0;
        1:  168:    s21_from_float_to_decimal(a, &src1);
        1:  169:    s21_from_int_to_decimal(b, &src2);
        1:  170:    res_od = s21_add(src1, src2);
        1:  171:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  172:    ck_assert_float_eq(res_od.value_type, s21_NORMAL_VALUE);
       1*:  173:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  174:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  175:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  176:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  177:    a = -1234;
        1:  178:    b = -221.234;
        1:  179:    res_our_dec = 0.0;
        1:  180:    s21_from_float_to_decimal(a, &src1);
        1:  181:    s21_from_float_to_decimal(b, &src2);
        1:  182:    res_origin = -1455.234;
        1:  183:    res_od = s21_add(src1, src2);
        1:  184:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  185:    ck_assert_float_eq(res_our_dec, res_origin);
        1:  186:    a = -9403;
        1:  187:    b = 0.00234;
        1:  188:    res_our_dec = 0.0;
        1:  189:    s21_from_float_to_decimal(a, &src1);
        1:  190:    s21_from_float_to_decimal(b, &src2);
        1:  191:    res_origin = -9402.99766;
        1:  192:    res_od = s21_add(src1, src2);
        1:  193:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  194:    ck_assert_float_eq(res_our_dec, res_origin);
        1:  195:    a = -9403;
        1:  196:    b = 234;
        1:  197:    res_our_dec = 0;
        1:  198:    s21_from_int_to_decimal(a, &src1);
        1:  199:    s21_from_int_to_decimal(b, &src2);
        1:  200:    res_origin = -9169;
        1:  201:    res_od = s21_add(src1, src2);
        1:  202:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  203:    ck_assert_int_eq(res_our_dec, res_origin);
        1:  204:    a = -0.94e03;
        1:  205:    b = -112.0234;
        1:  206:    res_our_dec = 0.0;
        1:  207:    s21_from_float_to_decimal(a, &src1);
        1:  208:    s21_from_float_to_decimal(b, &src2);
        1:  209:    res_origin = -1052.0234;
        1:  210:    res_od = s21_add(src1, src2);
        1:  211:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  212:    ck_assert_float_eq(res_our_dec, res_origin);
        1:  213:    a = -0.94e03;
        1:  214:    b = -112.0e2;
        1:  215:    res_our_dec = 0.0;
        1:  216:    s21_from_float_to_decimal(a, &src1);
        1:  217:    s21_from_float_to_decimal(b, &src2);
        1:  218:    res_origin = -12140;
        1:  219:    res_od = s21_add(src1, src2);
        1:  220:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  221:    ck_assert_float_eq(res_our_dec, res_origin);
        -:  222:
        1:  223:    src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  224:    src1.bits[3] = 0x300000;
        1:  225:    src1.bits[2] = 0;
        1:  226:    src1.bits[1] = 0xF;
        1:  227:    src1.bits[0] = 0x67E4FEEF;
        1:  228:    src2.bits[3] = 0x300000;
        1:  229:    src2.bits[2] = 0;
        1:  230:    src2.bits[1] = 0xFF;
        1:  231:    src2.bits[0] = 0x67E4FFFF;
        -:  232:    s21_decimal result_origin;
        1:  233:    result_origin.value_type = s21_NORMAL_VALUE;
        1:  234:    result_origin.bits[3] = 0x300000;
        1:  235:    result_origin.bits[2] = 0;
        1:  236:    result_origin.bits[1] = 0x10E;
        1:  237:    result_origin.bits[0] = 0xCFC9FEEE;
        1:  238:    s21_decimal result_our = s21_add(src1, src2);
       1*:  239:    ck_assert_int_eq(result_origin.bits[3], result_our.bits[3]);
       1*:  240:    ck_assert_int_eq(result_origin.bits[2], result_our.bits[2]);
       1*:  241:    ck_assert_int_eq(result_origin.bits[1], result_our.bits[1]);
       1*:  242:    ck_assert_int_eq(result_origin.bits[0], result_our.bits[0]);
        1:  243:    src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  244:    src1.bits[3] = 0x30000;
        1:  245:    src1.bits[2] = 0;
        1:  246:    src1.bits[1] = 0xFF;
        1:  247:    src1.bits[0] = 0x67E4F;
        1:  248:    src2.bits[3] = 0x60000;
        1:  249:    src2.bits[2] = 0;
        1:  250:    src2.bits[1] = 0xEA;
        1:  251:    src2.bits[0] = 0x67E4F;
        1:  252:    result_origin.value_type = s21_NORMAL_VALUE;
        1:  253:    result_origin.bits[3] = 0x60000;
        1:  254:    result_origin.bits[2] = 0;
        1:  255:    result_origin.bits[1] = 0x3E502;
        1:  256:    result_origin.bits[0] = 0x1963E2E7;
        1:  257:     result_our = s21_add(src1, src2);
       1*:  258:    ck_assert_int_eq(result_origin.bits[3], result_our.bits[3]);
       1*:  259:    ck_assert_int_eq(result_origin.bits[2], result_our.bits[2]);
       1*:  260:    ck_assert_int_eq(result_origin.bits[1], result_our.bits[1]);
       1*:  261:    ck_assert_int_eq(result_origin.bits[0], result_our.bits[0]);
        -:  262:
        -:  263:
        1:  264:    src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  265:    src1.bits[3] = 0x30000;
        1:  266:    src1.bits[2] = 0;
        1:  267:    src1.bits[1] = 0xFFFF;
        1:  268:    src1.bits[0] = 0xFF837E4F;
        1:  269:    src2.bits[3] = 0x80070000;
        1:  270:    src2.bits[2] = 0;
        1:  271:    src2.bits[1] = 0xFFF;
        1:  272:    src2.bits[0] = 0xFF837E4F;
        1:  273:    result_origin.value_type = s21_NORMAL_VALUE;
        1:  274:    result_origin.bits[3] = 0x70000;
        1:  275:    result_origin.bits[2] = 0;
        1:  276:    result_origin.bits[1] = 0x270FEFED;
        1:  277:    result_origin.bits[0] = 0x00F26FA1;
        1:  278:    result_our = s21_add(src1, src2);
       1*:  279:    ck_assert_int_eq(result_origin.bits[3], result_our.bits[3]);
       1*:  280:    ck_assert_int_eq(result_origin.bits[2], result_our.bits[2]);
       1*:  281:    ck_assert_int_eq(result_origin.bits[1], result_our.bits[1]);
       1*:  282:    ck_assert_int_eq(result_origin.bits[0], result_our.bits[0]);
        1:  283:    src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  284:    src1.bits[3] = 0x80030000;
        1:  285:    src1.bits[2] = 0;
        1:  286:    src1.bits[1] = 0xFFFF;
        1:  287:    src1.bits[0] = 0xFF837E4F;
        1:  288:    src2.bits[3] = 0x80070000;
        1:  289:    src2.bits[2] = 0;
        1:  290:    src2.bits[1] = 0xFFF;
        1:  291:    src2.bits[0] = 0xFF837E4F;
        1:  292:    result_origin.value_type = s21_NORMAL_VALUE;
        1:  293:    result_origin.bits[3] = 0x80070000;
        1:  294:    result_origin.bits[2] = 0;
        1:  295:    result_origin.bits[1] = 0x27100FEC;
        1:  296:    result_origin.bits[0] = 0xFFF96C3F;
        1:  297:    result_our = s21_add(src1, src2);
       1*:  298:    ck_assert_int_eq(result_origin.bits[3], result_our.bits[3]);
       1*:  299:    ck_assert_int_eq(result_origin.bits[2], result_our.bits[2]);
       1*:  300:    ck_assert_int_eq(result_origin.bits[1], result_our.bits[1]);
       1*:  301:    ck_assert_int_eq(result_origin.bits[0], result_our.bits[0]);
        1:  302:    src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  303:    src1.bits[3] = 0x80030000;
        1:  304:    src1.bits[2] = 0;
        1:  305:    src1.bits[1] = 0xFFFF;
        1:  306:    src1.bits[0] = 0xFF837E4F;
        1:  307:    src2.bits[3] = 0x70000;
        1:  308:    src2.bits[2] = 0;
        1:  309:    src2.bits[1] = 0xFFF;
        1:  310:    src2.bits[0] = 0xFF837E4F;
        1:  311:    result_origin.value_type = s21_NORMAL_VALUE;
        1:  312:    result_origin.bits[3] = 0x80070000;
        1:  313:    result_origin.bits[2] = 0;
        1:  314:    result_origin.bits[1] = 0x270FEFED;
        1:  315:    result_origin.bits[0] = 0x00F26FA1;
        1:  316:    result_our = s21_add(src1, src2);
       1*:  317:    ck_assert_int_eq(result_origin.bits[3], result_our.bits[3]);
       1*:  318:    ck_assert_int_eq(result_origin.bits[2], result_our.bits[2]);
       1*:  319:    ck_assert_int_eq(result_origin.bits[1], result_our.bits[1]);
       1*:  320:    ck_assert_int_eq(result_origin.bits[0], result_our.bits[0]);
        1:  321:}  END_TEST
        -:  322:
        -:  323:/*-----------Sub-----------*/
        1:  324:START_TEST(s21_decimal_test_sub) {
        1:  325:    int valuesA[] = {100, 100000, 1E+3, -111111, 1E+02};
        1:  326:    int valuesB[] = {100, 100000, 1E+2, -1, 1E+03};
        1:  327:    int originValues[] = {0, 0, 900, -111110, -900};
        -:  328:    s21_decimal src1, src2;
        -:  329:    int a;
        -:  330:    int b;
        -:  331:    int res_origin;
        -:  332:    int res_our_dec;
        5:  333:    for (int i = 0; i < 4; i++) {
        4:  334:        res_our_dec = 0;
        4:  335:        a = valuesA[i];
        4:  336:        b = valuesB[i];
        4:  337:        res_origin = originValues[i];
        4:  338:        s21_from_int_to_decimal(a, &src1);
        4:  339:        s21_from_int_to_decimal(b, &src2);
        4:  340:        s21_decimal res_od = s21_sub(src1, src2);
        4:  341:        s21_from_decimal_to_int(res_od, &res_our_dec);
       4*:  342:        ck_assert_int_eq(res_our_dec, res_origin);
        -:  343:}
        1:  344:} END_TEST
        1:  345:START_TEST(s21_decimal_test_sub2) {
        -:  346:    s21_decimal src1, src2;
        1:  347:    src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  348:    src1.bits[3] = 0b00000000000000010000000000000000;
        1:  349:    src1.bits[2] = 0;
        1:  350:    src1.bits[1] = 0;
        1:  351:    src1.bits[0] = 0b00000000000000000110011011110000;
        1:  352:    src2.bits[3] = 0b00000000000000110000000000000000;
        1:  353:    src2.bits[2] = 0;
        1:  354:    src2.bits[1] = 0;
        1:  355:    src2.bits[0] = 0b00000000000001000101000111010110;
        -:  356:    s21_decimal result_origin;
        1:  357:    result_origin.value_type = s21_NORMAL_VALUE;
        1:  358:    result_origin.bits[3] = 0b00000000000000110000000000000000;
        1:  359:    result_origin.bits[2] = 0;
        1:  360:    result_origin.bits[1] = 0;
        1:  361:    result_origin.bits[0] = 0b00000000001000111110001111101010;
        1:  362:    s21_decimal result_our = s21_sub(src1, src2);
       1*:  363:    ck_assert_int_eq(result_origin.bits[3], result_our.bits[3]);
       1*:  364:    ck_assert_int_eq(result_origin.bits[2], result_our.bits[2]);
       1*:  365:    ck_assert_int_eq(result_origin.bits[1], result_our.bits[1]);
       1*:  366:    ck_assert_int_eq(result_origin.bits[0], result_our.bits[0]);
        1:  367:    src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  368:    src1.bits[3] = 0b00000000000000110000000000000000;
        1:  369:    src1.bits[2] = 0;
        1:  370:    src1.bits[1] = 0;
        1:  371:    src1.bits[0] = 0b00000000000001000101000111010110;
        1:  372:    src2.bits[3] = 0b00000000000000010000000000000000;
        1:  373:    src2.bits[2] = 0;
        1:  374:    src2.bits[1] = 0;
        1:  375:    src2.bits[0] = 0b00000000000000000000101110111100;
        1:  376:    result_origin.value_type = s21_NORMAL_VALUE;
        1:  377:    result_origin.bits[3] = 0b10000000000000110000000000000000;
        1:  378:    result_origin.bits[2] = 0;
        1:  379:    result_origin.bits[1] = 0;
        1:  380:    result_origin.bits[0] = 0b00000000000000000100001110011010;
        1:  381:     result_our = s21_sub(src1, src2);
       1*:  382:    ck_assert_int_eq(result_origin.bits[3], result_our.bits[3]);
       1*:  383:    ck_assert_int_eq(result_origin.bits[2], result_our.bits[2]);
       1*:  384:    ck_assert_int_eq(result_origin.bits[1], result_our.bits[1]);
       1*:  385:    ck_assert_int_eq(result_origin.bits[0], result_our.bits[0]);
        1:  386:     src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  387:    src1.bits[3] = 0x80030000;
        1:  388:    src1.bits[2] = 0;
        1:  389:    src1.bits[1] = 0xFFFF;
        1:  390:    src1.bits[0] = 0xFF837E4F;
        1:  391:    src2.bits[3] = 0x80070000;
        1:  392:    src2.bits[2] = 0;
        1:  393:    src2.bits[1] = 0xFFF;
        1:  394:    src2.bits[0] = 0xFF837E4F;
        1:  395:    result_origin.value_type = s21_NORMAL_VALUE;
        1:  396:    result_origin.bits[3] = 0x80070000;
        1:  397:    result_origin.bits[2] = 0;
        1:  398:    result_origin.bits[1] = 0x270FEFED;
        1:  399:    result_origin.bits[0] = 0x00F26FA1;
        1:  400:     result_our = s21_sub(src1, src2);
       1*:  401:    ck_assert_int_eq(result_origin.bits[3], result_our.bits[3]);
       1*:  402:    ck_assert_int_eq(result_origin.bits[2], result_our.bits[2]);
       1*:  403:    ck_assert_int_eq(result_origin.bits[1], result_our.bits[1]);
       1*:  404:    ck_assert_int_eq(result_origin.bits[0], result_our.bits[0]);
        1:  405:    src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  406:    src1.bits[3] = 0x30000;
        1:  407:    src1.bits[2] = 0;
        1:  408:    src1.bits[1] = 0xFFFF;
        1:  409:    src1.bits[0] = 0xFF837E4F;
        1:  410:    src2.bits[3] = 0x80070000;
        1:  411:    src2.bits[2] = 0;
        1:  412:    src2.bits[1] = 0xFFF;
        1:  413:    src2.bits[0] = 0xFF837E4F;
        1:  414:    result_origin.value_type = s21_NORMAL_VALUE;
        1:  415:    result_origin.bits[3] = 0x70000;
        1:  416:    result_origin.bits[2] = 0;
        1:  417:    result_origin.bits[1] = 0x27100FEC;
        1:  418:    result_origin.bits[0] = 0xFFF96C3F;
        1:  419:     result_our = s21_sub(src1, src2);
       1*:  420:    ck_assert_int_eq(result_origin.bits[3], result_our.bits[3]);
       1*:  421:    ck_assert_int_eq(result_origin.bits[2], result_our.bits[2]);
       1*:  422:    ck_assert_int_eq(result_origin.bits[1], result_our.bits[1]);
       1*:  423:    ck_assert_int_eq(result_origin.bits[0], result_our.bits[0]);
        1:  424:     src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  425:    src1.bits[3] = 0b10000000000000010000000000000000;
        1:  426:    src1.bits[2] = 0;
        1:  427:    src1.bits[1] = 0;
        1:  428:    src1.bits[0] = 0b00000000000000000000000100110000;
        1:  429:    src2.bits[3] = 0b10000000000001100000000000000000;
        1:  430:    src2.bits[2] = 0;
        1:  431:    src2.bits[1] = 0;
        1:  432:    src2.bits[0] = 0b00010001001000010001101001100000;
        1:  433:    result_origin.value_type = s21_NORMAL_VALUE;
        1:  434:    result_origin.bits[3] = 0b00000000000001100000000000000000;
        1:  435:    result_origin.bits[2] = 0;
        1:  436:    result_origin.bits[1] = 0;
        1:  437:    result_origin.bits[0] = 0b00001111010100010011110001100000;
        1:  438:    result_our = s21_sub(src1, src2);
       1*:  439:    ck_assert_int_eq(result_origin.bits[3], result_our.bits[3]);
       1*:  440:    ck_assert_int_eq(result_origin.bits[2], result_our.bits[2]);
       1*:  441:    ck_assert_int_eq(result_origin.bits[1], result_our.bits[1]);
       1*:  442:    ck_assert_int_eq(result_origin.bits[0], result_our.bits[0]);
        1:  443:    src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  444:    src1.bits[3] = 0x80030000;
        1:  445:    src1.bits[2] = 0;
        1:  446:    src1.bits[1] = 0xFFFF;
        1:  447:    src1.bits[0] = 0xFF837E4F;
        1:  448:    src2.bits[3] = 0x70000;
        1:  449:    src2.bits[2] = 0;
        1:  450:    src2.bits[1] = 0xFFF;
        1:  451:    src2.bits[0] = 0xFF837E4F;
        1:  452:    result_origin.value_type = s21_NORMAL_VALUE;
        1:  453:    result_origin.bits[3] = 0x80070000;
        1:  454:    result_origin.bits[2] = 0;
        1:  455:    result_origin.bits[1] = 0x27100FEC;
        1:  456:    result_origin.bits[0] = 0xFFF96C3F;
        1:  457:     result_our = s21_sub(src1, src2);
       1*:  458:    ck_assert_int_eq(result_origin.bits[3], result_our.bits[3]);
       1*:  459:    ck_assert_int_eq(result_origin.bits[2], result_our.bits[2]);
       1*:  460:    ck_assert_int_eq(result_origin.bits[1], result_our.bits[1]);
       1*:  461:    ck_assert_int_eq(result_origin.bits[0], result_our.bits[0]);
        1:  462:    src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  463:    src1.bits[0] = 0b00000000000000000000011111100100;
        1:  464:    src1.bits[1] = 0b00000000000000000000000000000000;
        1:  465:    src1.bits[2] = 0b00000000000000000000000000000000;
        1:  466:    src1.bits[3] = 0b00000000000000000000000000000000;
        1:  467:    src2.bits[0] = 0b00000101100110111101101000011001;
        1:  468:    src2.bits[1] = 0b00000000000000000000000000000000;
        1:  469:    src2.bits[2] = 0b00000000000000000000000000000000;
        1:  470:    src2.bits[3] = 0b00000000000000000000000000000000;
        -:  471:    s21_decimal result;
        1:  472:    result_our = s21_sub(src2, src1);
        1:  473:    result.value_type = s21_NORMAL_VALUE;
        1:  474:    result.bits[0] = 0b00000101100110111101001000110101;
        1:  475:    result.bits[1] = 0b00000000000000000000000000000000;
        1:  476:    result.bits[2] = 0b00000000000000000000000000000000;
        1:  477:    result.bits[3] = 0b00000000000000000000000000000000;
       1*:  478:    ck_assert_int_eq(result.bits[3], result_our.bits[3]);
       1*:  479:    ck_assert_int_eq(result.bits[2], result_our.bits[2]);
       1*:  480:    ck_assert_int_eq(result.bits[1], result_our.bits[1]);
       1*:  481:    ck_assert_int_eq(result.bits[0], result_our.bits[0]);
        1:  482:    src1.value_type = src2.value_type = s21_NORMAL_VALUE;
        1:  483:    src1.bits[0] = 0b00000000000000000000011111100100;
        1:  484:    src1.bits[1] = 0b00000000000000000000000000000000;
        1:  485:    src1.bits[2] = 0b00000000000000000000000000000000;
        1:  486:    src1.bits[3] = 0b10000000000000000000000000000000;
        1:  487:    src2.bits[0] = 0b00000000000000000010010010111011;
        1:  488:    src2.bits[1] = 0b00000000000000000000000000000000;
        1:  489:    src2.bits[2] = 0b00000000000000000000000000000000;
        1:  490:    src2.bits[3] = 0b10000000000000000000000000000000;
        1:  491:    result_our = s21_sub(src2, src1);
        1:  492:    result.value_type = s21_NORMAL_VALUE;
        1:  493:    result.bits[0] = 0b00000000000000000001110011010111;
        1:  494:    result.bits[1] = 0b00000000000000000000000000000000;
        1:  495:    result.bits[2] = 0b00000000000000000000000000000000;
        1:  496:    result.bits[3] = 0b10000000000000000000000000000000;
       1*:  497:    ck_assert_int_eq(result.bits[3], result_our.bits[3]);
       1*:  498:    ck_assert_int_eq(result.bits[2], result_our.bits[2]);
       1*:  499:    ck_assert_int_eq(result.bits[1], result_our.bits[1]);
       1*:  500:    ck_assert_int_eq(result.bits[0], result_our.bits[0]);
        1:  501:} END_TEST
        -:  502:/*-----------Mult-----------*/
        1:  503:START_TEST(s21_decimal_test_mult) {
        1:  504:float valuesA[] = { 1010.123, 0.352, 1E+3, -1111.11, 11, 9403.0e2, 9403.0e2, -32768, -32768 };
        1:  505:float valuesB[] = { 100.1123, 0.16346, 1E+2, -1, 1E+03, 202, 9403.0e2, 2, 32768 };
        1:  506:float originValues[] = { 101125.737, 0.05753792, 100000, 1111.11, 11000,
        -:  507:189940600, 884164090000, -65536, -1073741824 };
        -:  508:    s21_decimal src1, src2;
        -:  509:    float a;
        -:  510:    float b;
        -:  511:    float res_origin;
        -:  512:    float res_our_dec;
       10:  513:    for (int i = 0; i < 9; i++) {
        9:  514:    res_our_dec = 0;
        9:  515:    a = valuesA[i];
        9:  516:    b = valuesB[i];
        9:  517:    res_origin = originValues[i];
        9:  518:        s21_from_float_to_decimal(a, &src1);
        9:  519:        s21_from_float_to_decimal(b, &src2);
        9:  520:        s21_decimal res_od = s21_mul(src1, src2);
        9:  521:        s21_from_decimal_to_float(res_od, &res_our_dec);
       9*:  522:        ck_assert_float_eq(res_our_dec, res_origin);
        -:  523:}
        1:  524:} END_TEST
        1:  525:START_TEST(s21_decimal_test_mult1) {
        -:  526:    s21_decimal src1, src2;
        1:  527:    float a = 1.0 / 0.0;
        1:  528:    int b = 0;
        1:  529:    float res_our_dec = 0.0;
        1:  530:    s21_from_float_to_decimal(a, &src1);
        1:  531:    s21_from_int_to_decimal(b, &src2);
        1:  532:    s21_decimal res_od = s21_mul(src1, src2);
        1:  533:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  534:    ck_assert_float_eq(res_od.value_type, s21_NAN);
       1*:  535:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  536:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  537:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  538:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  539:} END_TEST
        1:  540:START_TEST(s21_decimal_test_mult2) {
        -:  541:    s21_decimal src1, src2;
        1:  542:    float a = 1.0 / 0.0;
        1:  543:    float b = 132 / 0.0;
        1:  544:    float res_our_dec = 0.0;
        1:  545:    s21_from_float_to_decimal(a, &src1);
        1:  546:    s21_from_float_to_decimal(b, &src2);
        1:  547:    s21_decimal res_od = s21_mul(src1, src2);
        1:  548:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  549:    ck_assert_float_eq(res_od.value_type, s21_INFINITY);
       1*:  550:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  551:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  552:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  553:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  554:} END_TEST
        1:  555:START_TEST(s21_decimal_test_mult3) {
        -:  556:    s21_decimal src1, src2;
        1:  557:    float a = 1.0 / 0.0;
        1:  558:    float b = 1.0 / 0.0;
        1:  559:    float res_our_dec = 0.0;
        1:  560:    s21_from_float_to_decimal(a, &src1);
        1:  561:    s21_from_float_to_decimal(b, &src2);
        1:  562:    s21_decimal res_od = s21_mul(src1, src2);
        1:  563:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  564:    ck_assert_float_eq(res_od.value_type, s21_INFINITY);
       1*:  565:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  566:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  567:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  568:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  569:} END_TEST
        1:  570:START_TEST(s21_decimal_test_mult4) {
        -:  571:    s21_decimal src1, src2;
        1:  572:    float a = 1.0 / 0.0;
        1:  573:    float b = 0.0 / 0.0;
        1:  574:    float res_our_dec = 0.0;
        1:  575:    s21_from_float_to_decimal(a, &src1);
        1:  576:    s21_from_float_to_decimal(b, &src2);
        1:  577:    s21_decimal res_od = s21_mul(src1, src2);
        1:  578:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  579:    ck_assert_float_eq(res_od.value_type, s21_NAN);
       1*:  580:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  581:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  582:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  583:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  584:} END_TEST
        1:  585:START_TEST(s21_decimal_test_mult5) {
        -:  586:    s21_decimal src1, src2;
        1:  587:    float a = 9403.0e2;
        1:  588:    float b = 9403.0e2;
        1:  589:    float res_our_dec = 0.0;
        1:  590:    s21_from_float_to_decimal(a, &src1);
        1:  591:    s21_from_float_to_decimal(b, &src2);
        1:  592:    float res_origin = 884164090000;
        1:  593:    s21_decimal res_od = s21_mul(src1, src2);
        1:  594:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  595:    ck_assert_float_eq(res_our_dec, res_origin);
        1:  596:     a = 9403;
        1:  597:     b = 202;
        1:  598:    res_our_dec = 0;
        1:  599:    s21_from_int_to_decimal(a, &src1);
        1:  600:    s21_from_int_to_decimal(b, &src2);
        1:  601:    res_origin = 1899406;
        1:  602:     res_od = s21_mul(src1, src2);
        1:  603:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  604:    ck_assert_int_eq(res_our_dec, res_origin);
        1:  605:     a = -32768;
        1:  606:     b = 2;
        1:  607:     res_our_dec = 0;
        1:  608:    s21_from_int_to_decimal(a, &src1);
        1:  609:    s21_from_int_to_decimal(b, &src2);
        1:  610:     res_origin = -65536;
        1:  611:     res_od = s21_mul(src1, src2);
        1:  612:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  613:    ck_assert_int_eq(res_our_dec, res_origin);
        1:  614:     a = -32768;
        1:  615:     b = 32768;
        1:  616:     res_our_dec = 0;
        1:  617:    s21_from_int_to_decimal(a, &src1);
        1:  618:    s21_from_int_to_decimal(b, &src2);
        1:  619:     res_origin = -1073741824;
        1:  620:     res_od = s21_mul(src1, src2);
        1:  621:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  622:    ck_assert_int_eq(res_our_dec, res_origin);
        1:  623:    float d = 1.0 / 0.0;
        1:  624:     b = 0;
        1:  625:     res_our_dec = 0.0;
        1:  626:    s21_from_float_to_decimal(d, &src1);
        1:  627:    s21_from_float_to_decimal(b, &src2);
        1:  628:     res_od = s21_mul(src1, src2);
        1:  629:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  630:    ck_assert_float_eq(res_od.value_type, s21_NAN);
       1*:  631:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  632:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  633:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  634:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  635:    d = 1.0 / 0.0;
        1:  636:    b = 1.0 / 0.0;
        1:  637:     res_our_dec = 0.0;
        1:  638:    s21_from_float_to_decimal(a, &src1);
        1:  639:    s21_from_float_to_decimal(b, &src2);
        1:  640:     res_od = s21_mul(src1, src2);
        1:  641:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  642:    ck_assert_float_eq(res_od.value_type, s21_NEGATIVE_INFINITY);
       1*:  643:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  644:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  645:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  646:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  647:    d = 1.0 / 0.0;
        1:  648:     b = 0.0 / 0.0;
        1:  649:     res_our_dec = 0.0;
        1:  650:    s21_from_float_to_decimal(a, &src1);
        1:  651:    s21_from_float_to_decimal(b, &src2);
        1:  652:     res_od = s21_mul(src1, src2);
        1:  653:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  654:    ck_assert_float_eq(res_od.value_type, s21_NAN);
       1*:  655:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  656:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  657:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  658:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  659:     d = 1.0 / 0.0;
        1:  660:     b = -1.0 / 0.0;
        1:  661:     res_our_dec = 0.0;
        1:  662:    s21_from_float_to_decimal(a, &src1);
        1:  663:    s21_from_float_to_decimal(b, &src2);
        1:  664:     res_od = s21_mul(src1, src2);
        1:  665:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  666:    ck_assert_float_eq(res_od.value_type, s21_NEGATIVE_INFINITY);
       1*:  667:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  668:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  669:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  670:    ck_assert_int_eq(res_od.bits[0], 0);
        -:  671:
        1:  672:      d = -1.0 / 0.0;
        1:  673:     b = 123;
        1:  674:     res_our_dec = 0.0;
        1:  675:    s21_from_float_to_decimal(d, &src1);
        1:  676:    s21_from_float_to_decimal(b, &src2);
        1:  677:     res_od = s21_mul(src2, src1);
        1:  678:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  679:    ck_assert_float_eq(res_od.value_type, s21_NEGATIVE_INFINITY);
       1*:  680:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  681:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  682:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  683:    ck_assert_int_eq(res_od.bits[0], 0);
        -:  684:
        1:  685:      d = 1.0 / 0.0;
        1:  686:     b = 0;
        1:  687:     res_our_dec = 0.0;
        1:  688:    s21_from_float_to_decimal(d, &src1);
        1:  689:    s21_from_int_to_decimal(b, &src2);
        1:  690:     res_od = s21_mul(src2, src1);
        1:  691:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  692:    ck_assert_float_eq(res_od.value_type, s21_NAN);
       1*:  693:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  694:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  695:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  696:    ck_assert_int_eq(res_od.bits[0], 0);
        -:  697:
        1:  698:     d = -1.0 / 0.0;
        1:  699:     b = 0.0 / 0.0;
        1:  700:     res_our_dec = 0.0;
        1:  701:    s21_from_float_to_decimal(a, &src1);
        1:  702:    s21_from_float_to_decimal(b, &src2);
        1:  703:     res_od = s21_mul(src2, src1);
        1:  704:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  705:    ck_assert_float_eq(res_od.value_type, s21_NAN);
       1*:  706:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  707:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  708:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  709:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  710:     d = -1.0 / 0.0;
        1:  711:     b = 0.0 / 0.0;
        1:  712:     res_our_dec = 0.0;
        1:  713:    s21_from_float_to_decimal(a, &src1);
        1:  714:    s21_from_float_to_decimal(b, &src2);
        1:  715:     res_od = s21_mul(src1, src2);
        1:  716:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  717:    ck_assert_float_eq(res_od.value_type, s21_NAN);
       1*:  718:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  719:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  720:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  721:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  722:      d = 0.0 / 0.0;
        1:  723:     b = 0.0 / 0.0;
        1:  724:     res_our_dec = 0.0;
        1:  725:    s21_from_float_to_decimal(a, &src1);
        1:  726:    s21_from_float_to_decimal(b, &src2);
        1:  727:     res_od = s21_mul(src1, src2);
        1:  728:    s21_from_decimal_to_float(res_od, &res_our_dec);
       1*:  729:    ck_assert_float_eq(res_od.value_type, s21_NAN);
       1*:  730:    ck_assert_int_eq(res_od.bits[3], 0);
       1*:  731:    ck_assert_int_eq(res_od.bits[2], 0);
       1*:  732:    ck_assert_int_eq(res_od.bits[1], 0);
       1*:  733:    ck_assert_int_eq(res_od.bits[0], 0);
        1:  734:} END_TEST
        -:  735:
        1:  736:START_TEST(s21_decimal_test_mult6) {
        1:  737:    float b = 0, c = 0.001999999862164;
        1:  738:    float a1 = 2;
        1:  739:    float a2 = 10E26;
        -:  740:    s21_decimal decimal1, decimal2, decimal3;
        1:  741:    init_decimal(&decimal3);
        1:  742:    s21_from_float_to_decimal(a1, &decimal1);
        1:  743:    s21_from_float_to_decimal(a2, &decimal2);
        1:  744:    set_ten_power(30, &decimal2);
        1:  745:    decimal3 = s21_mul(decimal2, decimal1);
        1:  746:    s21_from_decimal_to_float(decimal3, &b);
       1*:  747:    ck_assert_float_eq(b, c);
        1:  748:} END_TEST
        -:  749:
        1:  750:START_TEST(s21_decimal_test_mult7) {
        1:  751:    float b = 0;
        1:  752:    float c = 0;
        1:  753:    float a1 = 0.02454;
        1:  754:    float a2 = 10E26;
        -:  755:    s21_decimal decimal1, decimal2, decimal3;
        1:  756:    init_decimal(&decimal3);
        1:  757:    s21_from_float_to_decimal(a1, &decimal1);
        1:  758:    s21_from_float_to_decimal(a2, &decimal2);
        1:  759:    set_ten_power(30, &decimal2);
        1:  760:    decimal3 = s21_mul(decimal2, decimal1);
        1:  761:    s21_from_decimal_to_float(decimal3, &b);
       1*:  762:    ck_assert_float_eq(b, c);
        -:  763:
        -:  764:
        1:  765:    b  = 20E+10;
        1:  766:    c = 30E+10;
        1:  767:    float res = 24539998789160995867590656.000000;
        1:  768:    s21_from_float_to_decimal(a1, &decimal1);
        1:  769:    s21_from_float_to_decimal(a2, &decimal2);
        1:  770:     decimal3 = s21_mul(decimal2, decimal1);
        1:  771:      s21_from_decimal_to_float(decimal3, &b);
       1*:  772:       ck_assert_float_eq(b, res);
        1:  773:} END_TEST
        -:  774:
        -:  775:
        -:  776:/*-----------Div-----------*/
        1:  777:START_TEST(s21_decimal_test_div) {
        1:  778:    float valuesA[] = { 1010.123, 5232, 1E+3, -1111.11, 11 };
        1:  779:    float valuesB[] = { 100.1123, 2, 1E+2, -1, 1E+03 };
        1:  780:    float originValues[] = { 10, 2616, 10, 1111 , 0 };   // 8=====D
        -:  781:    s21_decimal src1, src2;
        -:  782:    float a;
        -:  783:    float b;
        -:  784:    float res_origin;
        -:  785:    float res_our_dec;
        6:  786:    for (int i = 0; i < 5; i++) {
        5:  787:        res_our_dec = 0;
        5:  788:        a = valuesA[i];
        5:  789:        b = valuesB[i];
        5:  790:        res_origin = originValues[i];
        5:  791:        s21_from_float_to_decimal(a, &src1);
        5:  792:        s21_from_float_to_decimal(b, &src2);
        5:  793:        s21_decimal res_od = s21_div(src1, src2);
        5:  794:        s21_from_decimal_to_float(res_od, &res_our_dec);
       5*:  795:        ck_assert_float_eq(res_our_dec, res_origin);
        -:  796:}
        1:  797:} END_TEST
        1:  798:START_TEST(s21_decimal_test_div1) {
        1:  799:    float valuesA[] = { 0, 0, 1E+3, -1111.11, 11 };
        1:  800:    float valuesB[] = { 100.1123, -2, 1E+2, -1, 1E+03 };
        1:  801:    float originValues[] = { 0, 0, 10, 1111, 0 };
        -:  802:    s21_decimal src1, src2;
        -:  803:    float a;
        -:  804:    float b;
        -:  805:    float res_origin;
        -:  806:    float res_our_dec;
        6:  807:    for (int i = 0; i < 5; i++) {
        5:  808:        res_our_dec = 0;
        5:  809:        a = valuesA[i];
        5:  810:        b = valuesB[i];
        5:  811:        res_origin = originValues[i];
        5:  812:        s21_from_float_to_decimal(a, &src1);
        5:  813:        s21_from_float_to_decimal(b, &src2);
        5:  814:        s21_decimal res_od = s21_div(src1, src2);
        5:  815:        s21_from_decimal_to_float(res_od, &res_our_dec);
       5*:  816:        ck_assert_float_eq(res_our_dec, res_origin);
        -:  817:}
        1:  818:} END_TEST
        -:  819:/*-----------Mod-----------*/
        1:  820:START_TEST(s21_decimal_test_mod) {
        1:  821:    int valuesA[] = { 11240, 0, 1, 1E+09 };
        1:  822:    int valuesB[] = { 142, 0, 532, 1E+08 };
        1:  823:    int originValues[] = { 22, 0, 1, 0 };
        -:  824:    s21_decimal src1, src2;
        -:  825:    int a;
        -:  826:    int b;
        -:  827:    int res_origin;
        -:  828:    int res_our_dec;
        5:  829:    for (int i = 0; i < 4; i++) {
        4:  830:        res_our_dec = 0;
        4:  831:        a = valuesA[i];
        4:  832:        b = valuesB[i];
        4:  833:        res_origin = originValues[i];
        4:  834:        s21_from_int_to_decimal(a, &src1);
        4:  835:        s21_from_int_to_decimal(b, &src2);
        4:  836:        s21_decimal res_od = s21_mod(src1, src2);
        4:  837:        s21_from_decimal_to_int(res_od, &res_our_dec);
       4*:  838:        ck_assert_int_eq(res_our_dec, res_origin);
        -:  839:}
        1:  840:} END_TEST
        1:  841:START_TEST(s21_decimal_test_mod1) {
        -:  842:s21_decimal src1, src2, res_mod;
        1:  843:    int a = 3;
        1:  844:    int b = 2;
        1:  845:    int res_origin = a % b;
        1:  846:    int res = 0;
        1:  847:    s21_from_int_to_decimal(a, &src1);
        1:  848:    s21_from_int_to_decimal(b, &src2);
        1:  849:    res_mod = s21_mod(src1, src2);
        1:  850:    s21_from_decimal_to_int(res_mod, &res);
       1*:  851:    ck_assert_int_eq(res_origin, res);
        1:  852:} END_TEST
        -:  853:// MARK: - Another functions
        -:  854:/*-----------Negate-----------*/
        1:  855:START_TEST(s21_decimal_test_negate) {
        1:  856:    int valuesA[] = { 11240, 0, 1, 1E+04 };
        1:  857:    int originValues[] = { -11240, 0, -1, -10000 };
        -:  858:    s21_decimal src1;
        -:  859:    int a;
        -:  860:    int res_origin;
        -:  861:    int res_our_dec;
        5:  862:    for (int i = 0; i < 4; i++) {
        4:  863:        res_our_dec = 0;
        4:  864:        a = valuesA[i];
        4:  865:        res_origin = originValues[i];
        4:  866:        s21_from_int_to_decimal(a, &src1);
        4:  867:        s21_decimal res_od = s21_negate(src1);
        4:  868:        s21_from_decimal_to_int(res_od, &res_our_dec);
       4*:  869:        ck_assert_int_eq(res_our_dec, res_origin);
        -:  870:}
        1:  871:} END_TEST
        -:  872:/*-----------Truncate-----------*/
        1:  873:START_TEST(s21_decimal_test_truncate) {
        -:  874:    s21_decimal src1;
        -:  875:    s21_decimal result;
        -:  876:    s21_decimal res_od;
        1:  877:    src1.value_type = s21_NORMAL_VALUE;
        1:  878:    src1.bits[3] = 0x000A0000;
        1:  879:    src1.bits[2] = 0x0;
        1:  880:    src1.bits[1] = 0xFFFFFFFF;
        1:  881:    src1.bits[0] = 0xFFFFFFFF;
        1:  882:    result.bits[3] = 0x0;
        1:  883:    result.bits[2] = 0x0;
        1:  884:    result.bits[1] = 0x0;
        1:  885:    result.bits[0] = 0x6DF37F67;
        1:  886:    res_od = s21_truncate(src1);
       1*:  887:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*:  888:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*:  889:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*:  890:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1:  891:    src1.bits[3] = 0x800C0000;
        1:  892:    src1.bits[2] = 0x0;
        1:  893:    src1.bits[1] = 0xFFFFFFFF;
        1:  894:    src1.bits[0] = 0xFFFFFFFF;
        1:  895:    result.bits[3] = 0x80000000;
        1:  896:    result.bits[2] = 0x0;
        1:  897:    result.bits[1] = 0x0;
        1:  898:    result.bits[0] = 0x1197998;
        1:  899:    res_od = s21_truncate(src1);
       1*:  900:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*:  901:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*:  902:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*:  903:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1:  904:    src1.value_type = s21_NORMAL_VALUE;
        1:  905:    src1.bits[3] = 0x80000000;
        1:  906:    src1.bits[2] = 0x0;
        1:  907:    src1.bits[1] = 0xFFFFFFFF;
        1:  908:    src1.bits[0] = 0xFFFFFFFF;
        1:  909:    result.bits[3] = 0x80000000;
        1:  910:    result.bits[2] = 0x0;
        1:  911:    result.bits[1] = 0xFFFFFFFF;
        1:  912:    result.bits[0] = 0xFFFFFFFF;
        1:  913:    res_od = s21_truncate(src1);
       1*:  914:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*:  915:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*:  916:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*:  917:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1:  918:    src1.value_type = s21_NORMAL_VALUE;
        1:  919:    src1.bits[0] = 0b00000000000000000000000001101101;
        1:  920:    src1.bits[1] = 0b00000000000011000110010101011011;
        1:  921:    src1.bits[2] = 0b00000000000000000011000000111001;
        1:  922:    src1.bits[3] = 0b00000000000011100000000000000000;
        1:  923:    result.bits[0] = 0b10000111101111000001011000011110;
        1:  924:    result.bits[1] = 0b00000000000000000000000000000000;
        1:  925:    result.bits[2] = 0b00000000000000000000000000000000;
        1:  926:    result.bits[3] = 0b00000000000000000000000000000000;
        1:  927:    res_od = s21_truncate(src1);
       1*:  928:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*:  929:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*:  930:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*:  931:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1:  932:    src1.value_type = s21_NORMAL_VALUE;
        1:  933:    src1.bits[0] = 0b11011110101001001000000010110110;
        1:  934:    src1.bits[1] = 0b01011111101001011101111110100000;
        1:  935:    src1.bits[2] = 0b00011111111010011010111101100000;
        1:  936:    src1.bits[3] = 0b00000000000010010000000000000000;
        1:  937:    result.bits[0] = 0b00110100101011011100000100111110;
        1:  938:    result.bits[1] = 0b10001001000100001000011110111001;
        1:  939:    result.bits[2] = 0b00000000000000000000000000000000;
        1:  940:    result.bits[3] = 0b00000000000000000000000000000000;
        1:  941:    res_od = s21_truncate(src1);
       1*:  942:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*:  943:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*:  944:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*:  945:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1:  946:} END_TEST
        1:  947:START_TEST(s21_decimal_test_truncate1) {
        1:  948:    float valuesA[] = { 1123.1123, 0, -12.4124, -321 };
        1:  949:    float originValues[] = { 1123, 0, -12, -321 };
        -:  950:    s21_decimal src1, res_od;
        -:  951:    float a, b;
        5:  952:    for (int i = 0; i < 4; i++) {
        4:  953:        a = valuesA[i];
        4:  954:        s21_from_float_to_decimal(a, &src1);
        4:  955:        res_od = s21_truncate(src1);
        4:  956:        s21_from_decimal_to_float(res_od, &b);
       4*:  957:        ck_assert_float_eq(b, originValues[i]);
        -:  958:        }
        1:  959:} END_TEST
        -:  960:/*-----------Round-----------*/
        1:  961:START_TEST(s21_decimal_test_round) {
        -:  962:    s21_decimal src1;
        -:  963:    s21_decimal result;
        -:  964:    s21_decimal res_od;
        1:  965:    src1.value_type = s21_NORMAL_VALUE;
        1:  966:    src1.bits[0] = 0b01100011000011111111111111111111;
        1:  967:    src1.bits[1] = 0b01101011110001110101111000101101;
        1:  968:    src1.bits[2] = 0b00000000000000000000000000000101;
        1:  969:    src1.bits[3] = 0b10000000000010100000000000000000;
        1:  970:    result.bits[0] = 0b01010100000010111110010000000000;
        1:  971:    result.bits[1] = 0b00000000000000000000000000000010;
        1:  972:    result.bits[2] = 0b00000000000000000000000000000000;
        1:  973:    result.bits[3] = 0b10000000000000000000000000000000;
        1:  974:    res_od = s21_round(src1);
       1*:  975:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*:  976:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*:  977:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*:  978:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1:  979:    src1.value_type = s21_NORMAL_VALUE;
        1:  980:    src1.bits[0] = 0b01010101001110101110101110110001;
        1:  981:    src1.bits[1] = 0b00001101101101001101101001011111;
        1:  982:    src1.bits[2] = 0b00000000000000000000000000000000;
        1:  983:    src1.bits[3] = 0b10000000000100100000000000000000;
        1:  984:    result.bits[0] = 0b00000000000000000000000000000001;
        1:  985:    result.bits[1] = 0b00000000000000000000000000000000;
        1:  986:    result.bits[2] = 0b00000000000000000000000000000000;
        1:  987:    result.bits[3] = 0b10000000000000000000000000000000;
        1:  988:    res_od = s21_round(src1);
       1*:  989:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*:  990:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*:  991:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*:  992:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1:  993:    src1.value_type = s21_NORMAL_VALUE;
        1:  994:    src1.bits[0] = 0b10010011111100000001110001010010;
        1:  995:    src1.bits[1] = 0b00000000000000000000000100100000;
        1:  996:    src1.bits[2] = 0b00000000000000000000000000000000;
        1:  997:    src1.bits[3] = 0b00000000000010100000000000000000;
        1:  998:    result.bits[0] = 0b00000000000000000000000001111100;
        1:  999:    result.bits[1] = 0b00000000000000000000000000000000;
        1: 1000:    result.bits[2] = 0b00000000000000000000000000000000;
        1: 1001:    result.bits[3] = 0b00000000000000000000000000000000;
        1: 1002:    res_od = s21_round(src1);
       1*: 1003:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*: 1004:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*: 1005:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*: 1006:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1: 1007:    src1.value_type = s21_NORMAL_VALUE;
        1: 1008:    src1.bits[0] = 0b11001101110001110111110001000000;
        1: 1009:    src1.bits[1] = 0b00111110001001010000001001100000;
        1: 1010:    src1.bits[2] = 0b00100000010011111100111001011110;
        1: 1011:    src1.bits[3] = 0b10000000000001000000000000000000;
        1: 1012:    result.bits[0] = 0b10100000111111100100111000000100;
        1: 1013:    result.bits[1] = 0b00011011110011101100110011101101;
        1: 1014:    result.bits[2] = 0b00000000000000001101001111000010;
        1: 1015:    result.bits[3] = 0b10000000000000000000000000000000;
        1: 1016:    res_od = s21_round(src1);
       1*: 1017:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*: 1018:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*: 1019:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*: 1020:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1: 1021:    src1.value_type = s21_NORMAL_VALUE;
        1: 1022:    src1.bits[0] = 0b10100000111111100100111000000100;
        1: 1023:    src1.bits[1] = 0b00011011110011101100110011101101;
        1: 1024:    src1.bits[2] = 0b00000000000000001101001111000010;
        1: 1025:    src1.bits[3] = 0b00000000000000000000000000000000;
        1: 1026:    res_od = s21_round(src1);
        1: 1027:    result.bits[0] = 0b10100000111111100100111000000100;
        1: 1028:    result.bits[1] = 0b00011011110011101100110011101101;
        1: 1029:    result.bits[2] = 0b00000000000000001101001111000010;
        1: 1030:    result.bits[3] = 0b00000000000000000000000000000000;
       1*: 1031:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*: 1032:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*: 1033:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*: 1034:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1: 1035:} END_TEST
        -: 1036:/*-----------Floor-----------*/
        1: 1037:START_TEST(s21_decimal_test_floor) {
        -: 1038:    s21_decimal src1;
        -: 1039:    s21_decimal result;
        -: 1040:    s21_decimal res_od;
        1: 1041:    src1.value_type = s21_NORMAL_VALUE;
        1: 1042:    src1.bits[0] = 0b00001111111111111111111111111111;
        1: 1043:    src1.bits[1] = 0b00111110001001010000001001100001;
        1: 1044:    src1.bits[2] = 0b00100000010011111100111001011110;
        1: 1045:    src1.bits[3] = 0b00000000000010100000000000000000;
        1: 1046:    res_od = s21_floor(src1);
        1: 1047:    result.bits[0] = 0b10100111011000111111111111111111;
        1: 1048:    result.bits[1] = 0b00001101111000001011011010110011;
        1: 1049:    result.bits[2] = 0b00000000000000000000000000000000;
        1: 1050:    result.bits[3] = 0b00000000000000000000000000000000;
       1*: 1051:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*: 1052:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*: 1053:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*: 1054:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1: 1055:    src1.value_type = s21_NORMAL_VALUE;
        1: 1056:    src1.bits[0] = 0b00001111111111111111111111111111;
        1: 1057:    src1.bits[1] = 0b00111110001001010000001001100001;
        1: 1058:    src1.bits[2] = 0b00100000010011111100111001011110;
        1: 1059:    src1.bits[3] = 0b10000000000010100000000000000000;
        1: 1060:    res_od = s21_floor(src1);
        1: 1061:    result.bits[0] = 0b10100111011001000000000000000000;
        1: 1062:    result.bits[1] = 0b00001101111000001011011010110011;
        1: 1063:    result.bits[2] = 0b00000000000000000000000000000000;
        1: 1064:    result.bits[3] = 0b10000000000000000000000000000000;
       1*: 1065:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*: 1066:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*: 1067:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*: 1068:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1: 1069:    src1.value_type = s21_NORMAL_VALUE;
        1: 1070:    src1.bits[0] = 0b10111101001001111000010001010010;
        1: 1071:    src1.bits[1] = 0b00000000000000000000000000011100;
        1: 1072:    src1.bits[2] = 0b00000000000000000000000000000000;
        1: 1073:    src1.bits[3] = 0b10000000000010010000000000000000;
        1: 1074:    res_od = s21_floor(src1);
        1: 1075:    result.bits[0] = 0b00000000000000000000000001111100;
        1: 1076:    result.bits[1] = 0b00000000000000000000000000000000;
        1: 1077:    result.bits[2] = 0b00000000000000000000000000000000;
        1: 1078:    result.bits[3] = 0b10000000000000000000000000000000;
       1*: 1079:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*: 1080:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*: 1081:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*: 1082:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1: 1083:    src1.value_type = s21_NORMAL_VALUE;
        1: 1084:    src1.bits[0] = 0b10010011111100000001110001010010;
        1: 1085:    src1.bits[1] = 0b00000000000000000000000100100000;
        1: 1086:    src1.bits[2] = 0b00000000000000000000000000000000;
        1: 1087:    src1.bits[3] = 0b00000000000010100000000000000000;
        1: 1088:    res_od = s21_floor(src1);
        1: 1089:    result.bits[0] = 0b00000000000000000000000001111011;
        1: 1090:    result.bits[1] = 0b00000000000000000000000000000000;
        1: 1091:    result.bits[2] = 0b00000000000000000000000000000000;
        1: 1092:    result.bits[3] = 0b00000000000000000000000000000000;
       1*: 1093:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*: 1094:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*: 1095:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*: 1096:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1: 1097:    src1.value_type = s21_NORMAL_VALUE;
        1: 1098:    src1.bits[0] = 0b01010101001110101110101110110001;
        1: 1099:    src1.bits[1] = 0b00001101101101001101101001011111;
        1: 1100:    src1.bits[2] = 0b00000000000000000000000000000000;
        1: 1101:    src1.bits[3] = 0b10000000000100100000000000000000;
        1: 1102:    res_od = s21_floor(src1);
        1: 1103:    result.bits[0] = 0b00000000000000000000000000000001;
        1: 1104:    result.bits[1] = 0b00000000000000000000000000000000;
        1: 1105:    result.bits[2] = 0b00000000000000000000000000000000;
        1: 1106:    result.bits[3] = 0b10000000000000000000000000000000;
       1*: 1107:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*: 1108:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*: 1109:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*: 1110:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1: 1111:    src1.value_type = s21_NORMAL_VALUE;
        1: 1112:    src1.bits[0] = 0b01010101001110101110101110110001;
        1: 1113:    src1.bits[1] = 0b00001101101101001101101001011111;
        1: 1114:    src1.bits[2] = 0b00000000000000000000000000000000;
        1: 1115:    src1.bits[3] = 0b00000000000100100000000000000000;
        1: 1116:    res_od = s21_floor(src1);
        1: 1117:    result.bits[0] = 0b00000000000000000000000000000000;
        1: 1118:    result.bits[1] = 0b00000000000000000000000000000000;
        1: 1119:    result.bits[2] = 0b00000000000000000000000000000000;
        1: 1120:    result.bits[3] = 0b00000000000000000000000000000000;
       1*: 1121:    ck_assert_float_eq(res_od.bits[0], result.bits[0]);
       1*: 1122:    ck_assert_float_eq(res_od.bits[1], result.bits[1]);
       1*: 1123:    ck_assert_float_eq(res_od.bits[2], result.bits[2]);
       1*: 1124:    ck_assert_float_eq(res_od.bits[3], result.bits[3]);
        1: 1125:} END_TEST
        -: 1126:// MARK: - Comparison operatots
        -: 1127:/*-----------Less-----------*/
        1: 1128:START_TEST(s21_decimal_test_less) {
        1: 1129:    float valuesA[] = { 11240, 1, 12.4124, 1E+03 };
        1: 1130:    float valuesB[] = { 11240, 0, 1.6532, 1E+04 };
        1: 1131:    float originValues[] = { 1, 1, 1, 0 };
        -: 1132:    s21_decimal src1, src2;
        -: 1133:    int a, b;
        5: 1134:    for (int i = 0; i < 4; i++) {
        4: 1135:        a = valuesA[i];
        4: 1136:        b = valuesB[i];
        4: 1137:        s21_from_float_to_decimal(a, &src1);
        4: 1138:        s21_from_float_to_decimal(b, &src2);
       4*: 1139:        ck_assert_int_eq(s21_is_less(src1, src2), originValues[i]);
        -: 1140:        }
        1: 1141:} END_TEST
        -: 1142:/*-----------Less_or_equal-----------*/
        1: 1143:START_TEST(s21_decimal_test_less_or_equal) {
        1: 1144:    float valuesA[] = { 11240, 1, 12.4124, 1E+03 };
        1: 1145:    float valuesB[] = { 11240, 0, 1.6532, 1E+04 };
        1: 1146:    float originValues[] = { 0, 1, 1, 0 };
        -: 1147:    s21_decimal src1, src2;
        -: 1148:    int a, b;
        5: 1149:    for (int i = 0; i < 4; i++) {
        4: 1150:        a = valuesA[i];
        4: 1151:        b = valuesB[i];
        4: 1152:        s21_from_float_to_decimal(a, &src1);
        4: 1153:        s21_from_float_to_decimal(b, &src2);
       4*: 1154:        ck_assert_int_eq(s21_is_less_or_equal(src1, src2), originValues[i]);
        -: 1155:        }
        1: 1156:} END_TEST
        -: 1157:/*-----------Greater than-----------*/
        1: 1158:START_TEST(s21_decimal_test_greather) {
        1: 1159:    float valuesA[] = { 11241, 1, 12.4124, 1E+03 };
        1: 1160:    float valuesB[] = { 11240, 0, 1.6532, 1E+04 };
        1: 1161:    float originValues[] = { 0, 0, 0, 1 };
        -: 1162:    s21_decimal src1, src2;
        -: 1163:    int a, b;
        2: 1164:    for (int i = 0; i < 1; i++) {
        1: 1165:        a = valuesA[i];
        1: 1166:        b = valuesB[i];
        1: 1167:        s21_from_float_to_decimal(a, &src1);
        1: 1168:        s21_from_float_to_decimal(b, &src2);
       1*: 1169:        ck_assert_int_eq(s21_is_greater(src1, src2), originValues[i]);
        -: 1170:        }
        1: 1171:} END_TEST
        -: 1172:/*-----------Greater than or equal to-----------*/
        1: 1173:START_TEST(s21_decimal_test_greather_or_equal) {
        1: 1174:    float valuesA[] = { 11240, 1, 12.4124, 1E+03 };
        1: 1175:    float valuesB[] = { 11240, 0, 1.6532, 1E+04 };
        1: 1176:    float originValues[] = { 0, 0, 0, 1 };
        -: 1177:    s21_decimal src1, src2;
        -: 1178:    int a, b;
        5: 1179:    for (int i = 0; i < 4; i++) {
        4: 1180:        a = valuesA[i];
        4: 1181:        b = valuesB[i];
        4: 1182:        s21_from_float_to_decimal(a, &src1);
        4: 1183:        s21_from_float_to_decimal(b, &src2);
       4*: 1184:        ck_assert_int_eq(s21_is_greater_or_equal(src1, src2), originValues[i]);
        -: 1185:        }
        1: 1186:} END_TEST
        -: 1187:/*-----------Equal to-----------*/
        1: 1188:START_TEST(s21_decimal_test_equal_to) {
        1: 1189:    float valuesA[] = {11240, 1, 12.4124, 1E+03 };
        1: 1190:    float valuesB[] = { 11240, 0, 1.6532, 1E+04 };
        1: 1191:    float originValues[] = { 0, 1, 1, 1 };
        -: 1192:    s21_decimal src1, src2;
        -: 1193:    int a, b;
        5: 1194:    for (int i = 0; i < 4; i++) {
        4: 1195:        a = valuesA[i];
        4: 1196:        b = valuesB[i];
        4: 1197:        s21_from_float_to_decimal(a, &src1);
        4: 1198:        s21_from_float_to_decimal(b, &src2);
       4*: 1199:        ck_assert_int_eq(s21_is_equal(src1, src2), originValues[i]);
        -: 1200:        }
        1: 1201:} END_TEST
        -: 1202:/*-----------Not equal to-----------*/
        1: 1203:START_TEST(s21_decimal_test_is_not_equal_to) {
        1: 1204:    float valuesA[] = { 11240, 1, 12.4124, 1E+04 };
        1: 1205:    float valuesB[] = { 1120, 0, 1.6532, 1E+04 };
        1: 1206:    float originValues[] = { 0, 0, 0, 1 };
        -: 1207:    s21_decimal src1, src2;
        -: 1208:    int a, b;
        5: 1209:    for (int i = 0; i < 4; i++) {
        4: 1210:        a = valuesA[i];
        4: 1211:        b = valuesB[i];
        4: 1212:        s21_from_float_to_decimal(a, &src1);
        4: 1213:        s21_from_float_to_decimal(b, &src2);
       4*: 1214:        ck_assert_int_eq(s21_is_not_equal(src1, src2), originValues[i]);
        -: 1215:        }
        1: 1216:} END_TEST
        -: 1217:/*-----------Check before sub-----------*/
        1: 1218:START_TEST(s21_decimal_test_check_before_sub) {
        1: 1219:    float valuesA[] = { -2147483647, 0, 22.22, -22.22 };
        1: 1220:    float valuesB[] = { 2147483647, 1, 2, -22.22 };
        1: 1221:    float originValues[] = { 2, 0, 11.11, 1 };
        1: 1222:    int values[] = { 1, 1, 1, 1 };
        -: 1223:    float a, b, c;
        -: 1224:    s21_decimal src1, src2, src3;
        5: 1225:    for (int i = 0; i < 4; i++) {
        4: 1226:        a = valuesA[i];
        4: 1227:        b = valuesB[i];
        4: 1228:        c = originValues[i];
        4: 1229:        s21_from_float_to_decimal(a, &src1);
        4: 1230:        s21_from_float_to_decimal(b, &src2);
        4: 1231:        s21_from_float_to_decimal(c, &src3);
       4*: 1232:        ck_assert_int_eq(check_before_sub(src1, src2, &src3), values[i]);
        -: 1233:        }
        1: 1234:} END_TEST
        1: 1235:START_TEST(s21_decimal_shift) {
        1: 1236:        float a = 100;
        -: 1237:        float res;
        1: 1238:        float res_origin = 50.000000;
        -: 1239:        s21_decimal src1;
        1: 1240:        s21_from_float_to_decimal(a, &src1);
        1: 1241:        shift(&src1, -1);
        1: 1242:        s21_from_decimal_to_float(src1, &res);
       1*: 1243:        ck_assert_float_eq(res_origin, res);
        1: 1244:} END_TEST
       34: 1245:int main() {
       34: 1246:    Suite *s1 = suite_create("Convertors and parsers");
       34: 1247:    TCase *s21_decimal_tests = tcase_create("Tests");
       34: 1248:    suite_add_tcase(s1, s21_decimal_tests);
       34: 1249:    tcase_add_test(s21_decimal_tests, s21_decimal_test_from_int);
       34: 1250:    tcase_add_test(s21_decimal_tests, s21_decimal_test_from_float);
       34: 1251:    tcase_add_test(s21_decimal_tests, s21_decimal_test_from_decimal_to_int);
       34: 1252:    tcase_add_test(s21_decimal_tests, s21_decimal_test_from_decimal_to_float);
       34: 1253:    Suite *s2 = suite_create("Comparison Operators");
       34: 1254:    TCase *s21_decimal_tests2 = tcase_create("Tests");
       34: 1255:    suite_add_tcase(s2, s21_decimal_tests2);
       34: 1256:    tcase_add_test(s21_decimal_tests2, s21_decimal_test_less);
       34: 1257:    tcase_add_test(s21_decimal_tests2, s21_decimal_test_less_or_equal);
       34: 1258:    tcase_add_test(s21_decimal_tests2,   s21_decimal_test_greather);
       34: 1259:    tcase_add_test(s21_decimal_tests2,   s21_decimal_test_greather_or_equal);
       34: 1260:    tcase_add_test(s21_decimal_tests2,   s21_decimal_test_equal_to);
       34: 1261:    tcase_add_test(s21_decimal_tests2,   s21_decimal_test_is_not_equal_to);
       34: 1262:    tcase_add_test(s21_decimal_tests2,   s21_decimal_test_check_before_sub);
       34: 1263:    Suite *s3 = suite_create("Arithmetic Operators");
       34: 1264:    TCase *s21_decimal_tests3 = tcase_create("Tests");
       34: 1265:    suite_add_tcase(s3, s21_decimal_tests3);
       34: 1266:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_add);
       34: 1267:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_sub);
       34: 1268:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_mult);
       34: 1269:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_mult1);
       34: 1270:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_mult2);
       34: 1271:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_mult3);
       34: 1272:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_mult4);
       34: 1273:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_div);
       34: 1274:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_div1);
       34: 1275:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_mod);
       34: 1276:     tcase_add_test(s21_decimal_tests3, s21_decimal_test_mod1);
       34: 1277:    tcase_add_test(s21_decimal_tests3, s21_decimal_shift);
       34: 1278:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_add1);
       34: 1279:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_sub2);
       34: 1280:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_mult5);
       34: 1281:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_mult6);
       34: 1282:    tcase_add_test(s21_decimal_tests3, s21_decimal_test_mult7);
        -: 1283:
       34: 1284:    Suite *s4 = suite_create("Another functions");
       34: 1285:    TCase *s21_decimal_tests4 = tcase_create("Tests");
       34: 1286:    suite_add_tcase(s4, s21_decimal_tests4);
       34: 1287:    tcase_add_test(s21_decimal_tests4, s21_decimal_test_negate);
       34: 1288:    tcase_add_test(s21_decimal_tests4, s21_decimal_test_truncate);
       34: 1289:    tcase_add_test(s21_decimal_tests4, s21_decimal_test_truncate1);
       34: 1290:    tcase_add_test(s21_decimal_tests4, s21_decimal_test_round);
       34: 1291:    tcase_add_test(s21_decimal_tests4, s21_decimal_test_floor);
       34: 1292:    SRunner *runner = srunner_create(s1);
       34: 1293:    SRunner *runner1 = srunner_create(s2);
       34: 1294:    SRunner *runner2 = srunner_create(s3);
       34: 1295:    SRunner *runner3 = srunner_create(s4);
        -: 1296:
       34: 1297:    srunner_run_all(runner, CK_NORMAL);
       30: 1298:    srunner_run_all(runner1, CK_NORMAL);
       23: 1299:    srunner_run_all(runner2, CK_NORMAL);
        6: 1300:    srunner_run_all(runner3, CK_NORMAL);
        1: 1301:    srunner_free(runner);
        1: 1302:    srunner_free(runner1);
        1: 1303:    srunner_free(runner2);
        1: 1304:    srunner_free(runner3);
        1: 1305:    return 0;
        -: 1306:}
